# ml-service/main.py
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import List, Dict, Any, Optional
import pandas as pd
import numpy as np
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, confusion_matrix, roc_auc_score
import joblib
import json
import os
from datetime import datetime, timedelta
import random
import logging
import time

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(
    title="Fraud Detection ML Service",
    description="Sistema de Detecção de Fraudes em Tempo Real",
    version="1.0.0"
)

# Global variables
model = None
model_metrics = {}
processing_times = []

class Transaction(BaseModel):
    id: str
    user_id: str
    amount: float
    merchant: str
    location: Dict[str, float]  # {"lat": -23.5505, "lng": -46.6333}
    timestamp: str
    card_type: str = "credit"
    transaction_type: str = "purchase"

class FraudPrediction(BaseModel):
    transaction_id: str
    fraud_score: float
    risk_level: str
    reasons: List[str]
    processing_time_ms: int
    timestamp: str

def generate_synthetic_data(n_samples: int = 10000):
    """Gera dataset sintético de transações bancárias"""
    logger.info(f"Gerando {n_samples} transações sintéticas...")
    
    np.random.seed(42)
    random.seed(42)
    
    data = []
    
    # Listas para variar os dados
    merchants = [
        "Amazon", "Mercado Livre", "Magazine Luiza", "Americanas", "Shopee",
        "McDonald's", "Burger King", "Subway", "KFC", "Pizza Hut",
        "Shell", "Petrobras", "Ipiranga", "BR Distribuidora",
        "Carrefour", "Extra", "Pão de Açúcar", "Walmart",
        "Netflix", "Spotify", "Amazon Prime", "Disney+",
        "Uber", "99", "iFood", "Rappi"
    ]
    
    card_types = ["credit", "debit"]
    transaction_types = ["purchase", "withdrawal", "transfer", "payment"]
    
    # Coordenadas de algumas cidades brasileiras
    cities = {
        "São Paulo": {"lat": -23.5505, "lng": -46.6333},
        "Rio de Janeiro": {"lat": -22.9068, "lng": -43.1729},
        "Brasília": {"lat": -15.7801, "lng": -47.9292},
        "Salvador": {"lat": -12.9714, "lng": -38.5014},
        "Fortaleza": {"lat": -3.7319, "lng": -38.5267},
        "Belo Horizonte": {"lat": -19.9167, "lng": -43.9345},
        "Recife": {"lat": -8.0476, "lng": -34.8770}
    }
    
    for i in range(n_samples):
        # Gerar timestamp aleatório (últimos 30 dias)
        days_ago = random.randint(0, 30)
        hours = random.randint(0, 23)
        minutes = random.randint(0, 59)
        timestamp = datetime.now() - timedelta(days=days_ago, hours=hours, minutes=minutes)
        
        # Determinar se é fraude (5% de chance)
        is_fraud = random.random() < 0.05
        
        # Gerar user_id (simular 1000 usuários diferentes)
        user_id = f"user_{random.randint(1, 1000)}"
        
        # Escolher localização
        city_name = random.choice(list(cities.keys()))
        base_location = cities[city_name]
        
        # Adicionar pequena variação na localização
        location = {
            "lat": base_location["lat"] + random.uniform(-0.1, 0.1),
            "lng": base_location["lng"] + random.uniform(-0.1, 0.1)
        }
        
        # Gerar valor da transação
        if is_fraud:
            # Fraudes tendem a ter valores mais altos e horários estranhos
            amount = random.uniform(1000, 10000)  # Valores altos
            if random.random() < 0.3:  # 30% das fraudes em horários estranhos
                hour = random.choice([2, 3, 4, 5, 23, 0, 1])
                timestamp = timestamp.replace(hour=hour)
        else:
            # Transações normais
            amount = random.uniform(10, 500)  # Valores mais baixos
        
        # Features derivadas para o modelo
        hour = timestamp.hour
        day_of_week = timestamp.weekday()
        is_weekend = day_of_week >= 5
        is_night = hour >= 22 or hour <= 6
        
        # Simular velocidade de transações (transações por hora para o usuário)
        transactions_last_hour = random.randint(0, 5) if not is_fraud else random.randint(3, 15)
        
        # Distância de "casa" (simulada)
        distance_from_home = random.uniform(0, 5) if not is_fraud else random.uniform(10, 100)
        
        # Valor vs média do usuário (simulado)
        user_avg = 150  # Média simulada
        amount_vs_avg = amount / user_avg
        
        transaction = {
            "id": f"txn_{i+1:06d}",
            "user_id": user_id,
            "amount": round(amount, 2),
            "merchant": random.choice(merchants),
            "location": location,
            "timestamp": timestamp.isoformat(),
            "card_type": random.choice(card_types),
            "transaction_type": random.choice(transaction_types),
            "is_fraud": int(is_fraud),
            # Features engineered
            "hour": hour,
            "day_of_week": day_of_week,
            "is_weekend": int(is_weekend),
            "is_night": int(is_night),
            "transactions_last_hour": transactions_last_hour,
            "distance_from_home": round(distance_from_home, 2),
            "amount_vs_avg": round(amount_vs_avg, 2)
        }
        
        data.append(transaction)
    
    df = pd.DataFrame(data)
    logger.info(f"Dataset gerado: {len(df)} transações, {df['is_fraud'].sum()} fraudes ({df['is_fraud'].mean()*100:.1f}%)")
    
    return df

def prepare_features(df):
    """Prepara features para o modelo ML"""
    feature_columns = [
        'amount', 'hour', 'day_of_week', 'is_weekend', 'is_night',
        'transactions_last_hour', 'distance_from_home', 'amount_vs_avg'
    ]
    
    return df[feature_columns].values

def train_model():
    """Treina o modelo Random Forest"""
    global model, model_metrics
    
    logger.info("Iniciando treinamento do modelo...")
    
    # Gerar dados sintéticos
    df = generate_synthetic_data(10000)
    
    # Preparar features e target
    X = prepare_features(df)
    y = df['is_fraud'].values
    
    # Split train/test
    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.2, random_state=42, stratify=y
    )
    
    # Treinar Random Forest
    model = RandomForestClassifier(
        n_estimators=100,
        max_depth=10,
        min_samples_split=5,
        min_samples_leaf=2,
        random_state=42,
        class_weight='balanced'  # Para lidar com classes desbalanceadas
    )
    
    model.fit(X_train, y_train)
    
    # Avaliar modelo
    y_pred = model.predict(X_test)
    y_pred_proba = model.predict_proba(X_test)[:, 1]
    
    # Calcular métricas
    from sklearn.metrics import precision_score, recall_score, f1_score
    
    model_metrics = {
        "precision": float(precision_score(y_test, y_pred)),
        "recall": float(recall_score(y_test, y_pred)),
        "f1_score": float(f1_score(y_test, y_pred)),
        "roc_auc": float(roc_auc_score(y_test, y_pred_proba)),
        "training_samples": len(X_train),
        "test_samples": len(X_test),
        "fraud_rate": float(y.mean()),
        "last_trained": datetime.now().isoformat()
    }
    
    # Salvar modelo
    os.makedirs("saved_models", exist_ok=True)
    joblib.dump(model, "saved_models/random_forest.pkl")
    
    # Salvar métricas
    with open("saved_models/model_metrics.json", "w") as f:
        json.dump(model_metrics, f, indent=2)
    
    logger.info(f"Modelo treinado! Métricas: Precision={model_metrics['precision']:.3f}, Recall={model_metrics['recall']:.3f}, F1={model_metrics['f1_score']:.3f}")
    
    return model_metrics

def engineer_features(transaction: dict):
    """Feature engineering para uma transação individual"""
    timestamp = datetime.fromisoformat(transaction["timestamp"].replace('Z', '+00:00'))
    
    # Features básicas
    features = {
        "amount": transaction["amount"],
        "hour": timestamp.hour,
        "day_of_week": timestamp.weekday(),
        "is_weekend": int(timestamp.weekday() >= 5),
        "is_night": int(timestamp.hour >= 22 or timestamp.hour <= 6),
    }
    
    # Features simuladas (em produção viriam do histórico do usuário)
    features.update({
        "transactions_last_hour": random.randint(0, 3),  # Simulado
        "distance_from_home": random.uniform(0, 20),      # Simulado
        "amount_vs_avg": transaction["amount"] / 150       # Simulado (média=150)
    })
    
    return features

@app.on_event("startup")
async def startup_event():
    """Carrega ou treina modelo na inicialização"""
    global model, model_metrics
    
    try:
        # Tentar carregar modelo existente
        model = joblib.load("saved_models/random_forest.pkl")
        with open("saved_models/model_metrics.json", "r") as f:
            model_metrics = json.load(f)
        logger.info("Modelo carregado com sucesso!")
    except FileNotFoundError:
        logger.info("Modelo não encontrado. Treinando novo modelo...")
        train_model()

@app.get("/")
async def root():
    return {
        "message": "Fraud Detection ML Service",
        "status": "running",
        "model_loaded": model is not None,
        "version": "1.0.0"
    }

@app.post("/predict", response_model=FraudPrediction)
async def predict_fraud(transaction: Transaction):
    """Predição de fraude para uma transação"""
    start_time = time.time()
    
    if model is None:
        raise HTTPException(status_code=503, detail="Model not loaded")
    
    try:
        # Feature engineering
        features = engineer_features(transaction.dict())
        
        # Preparar features para o modelo
        feature_array = np.array([[
            features["amount"],
            features["hour"],
            features["day_of_week"],
            features["is_weekend"],
            features["is_night"],
            features["transactions_last_hour"],
            features["distance_from_home"],
            features["amount_vs_avg"]
        ]])
        
        # Predição
        fraud_probability = model.predict_proba(feature_array)[0][1]
        
        # Determinar nível de risco
        if fraud_probability > 0.8:
            risk_level = "HIGH"
            reasons = [
                "Probabilidade de fraude muito alta",
                "Padrão anômalo detectado"
            ]
        elif fraud_probability > 0.5:
            risk_level = "MEDIUM"
            reasons = [
                "Alguns indicadores de risco presentes",
                "Requer análise adicional"
            ]
        else:
            risk_level = "LOW"
            reasons = [
                "Padrão normal de transação",
                "Baixo risco detectado"
            ]
        
        # Adicionar razões específicas baseadas nas features
        if features["amount_vs_avg"] > 3:
            reasons.append("Valor muito acima da média do usuário")
        if features["is_night"]:
            reasons.append("Transação em horário noturno")
        if features["distance_from_home"] > 50:
            reasons.append("Localização muito distante do padrão")
        if features["transactions_last_hour"] > 5:
            reasons.append("Muitas transações em pouco tempo")
        
        # Calcular tempo de processamento
        processing_time = int((time.time() - start_time) * 1000)
        processing_times.append(processing_time)
        
        # Manter apenas os últimos 100 tempos
        if len(processing_times) > 100:
            processing_times.pop(0)
        
        result = FraudPrediction(
            transaction_id=transaction.id,
            fraud_score=round(fraud_probability, 4),
            risk_level=risk_level,
            reasons=reasons[:3],  # Máximo 3 razões
            processing_time_ms=processing_time,
            timestamp=datetime.now().isoformat()
        )
        
        logger.info(f"Predição: {transaction.id} -> {risk_level} (score: {fraud_probability:.3f}, {processing_time}ms)")
        
        return result
        
    except Exception as e:
        logger.error(f"Erro na predição: {str(e)}")
        raise HTTPException(status_code=500, detail=f"Prediction error: {str(e)}")

@app.post("/retrain")
async def retrain_model():
    """Retreina o modelo com novos dados"""
    try:
        metrics = train_model()
        return {
            "message": "Model retrained successfully",
            "metrics": metrics,
            "timestamp": datetime.now().isoformat()
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Retraining error: {str(e)}")

@app.get("/metrics")
async def get_metrics():
    """Retorna métricas do modelo e sistema"""
    avg_processing_time = sum(processing_times) / len(processing_times) if processing_times else 0
    
    return {
        "model_metrics": model_metrics,
        "system_metrics": {
            "avg_processing_time_ms": round(avg_processing_time, 2),
            "predictions_count": len(processing_times),
            "model_loaded": model is not None,
            "uptime": "running"
        },
        "timestamp": datetime.now().isoformat()
    }

@app.get("/health")
async def health_check():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "model_loaded": model is not None,
        "timestamp": datetime.now().isoformat()
    }

# Endpoint para gerar dados de teste
@app.get("/generate-test-data")
async def generate_test_data():
    """Gera algumas transações de teste"""
    test_transactions = []
    
    for i in range(5):
        is_fraud_sim = i == 4  # Última transação será suspeita
        
        transaction = {
            "id": f"test_txn_{i+1}",
            "user_id": f"test_user_{random.randint(1, 10)}",
            "amount": random.uniform(1000, 5000) if is_fraud_sim else random.uniform(20, 200),
            "merchant": random.choice(["Amazon", "McDonald's", "Shell", "Carrefour"]),
            "location": {"lat": -23.5505, "lng": -46.6333},
            "timestamp": datetime.now().isoformat(),
            "card_type": "credit",
            "transaction_type": "purchase"
        }
        
        test_transactions.append(transaction)
    
    return {
        "test_transactions": test_transactions,
        "message": "Use these transactions to test the /predict endpoint"
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8001)